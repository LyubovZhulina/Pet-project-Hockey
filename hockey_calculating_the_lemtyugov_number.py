# -*- coding: utf-8 -*-
"""MAIN of Hockey: calculating the Lemtyugov number.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18LJ38YmjtA8my-dXwjQxewdZ9wyalv8q

# РЕТ-проект “Хоккей: расчет числа Лемтюгова”

**Цель проекта**: Создать аналог числа Эрдёша — Бэйкона для отечественных хоккеистов, называемый числом Лемтюгова, чтобы измерять "близость" хоккеистов к Николаю Лемтюгову через команды, в которых они играли.

**Задачи проекта**:

1. Собрать данные об отечественных хоккеистах и командах, в которых они играли.
2. Рассчитать число Лемтюгова для каждого хоккеиста.
3. Построить дэшборд или отчет с графами, отображающими связи между хоккеистами и количеством команд, через которые они были связаны.

**Данные**

Датасет `players` содержит информацию о хокеисте, как личные данные, так и место в команде по сезонам:

- `player_link` - ссылка на страницу игрока, уникальное поле
- `player` - Имя игрока
- `team` - команда
- `start_date` - начало игры в команде
- `end_date` - завершение игры в команде

Датасет `personal_data` содержит персональные данные ингрока и его награды.

Датасет `stats` включает статистические данные по проведенным хоккеистом играх.

## Изучение общей информации. Предобработка данных
"""

# импортируем библиотеки
import pandas as pd
from datetime import datetime, date, time
import numpy as np

# основные графические библиотеки
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objs as go
import plotly.express as px
from plotly.subplots import make_subplots

# библиотека визуализации bokeh и фронтенд для вывода - holoviews
import holoviews as hv
import bokeh
from holoviews import opts, dim
import holoviews.plotting.bokeh
from bokeh.plotting import show, output_file
hv.extension('bokeh')

# request - чтобы подтягивать информацию с других сайтов - используется в функции отрисовки sankey чарта
import requests

# для отображения прогресса - используется в функции отрисовки sankey чарта
from tqdm import tqdm

# библиотека для работы с очередями - для прохода по графу
from queue import Queue

# для работы с графами и их визуализации
import networkx as nx

# статистические библиотеки
import scipy.stats as st
from statsmodels.stats.proportion import proportions_ztest

pd.options.mode.chained_assignment = None

# сторонняя библиотека для корреляций
!pip install phik --quiet
import phik

# сторонняя библиотека для визуализации графа
!pip install scikit-image --quiet
!pip install datashader --quiet
from holoviews.operation.datashader import datashade, bundle_graph

# сторонняя библиотека для визуализации карты
!pip install geopy --quiet

# библиотеки для геоданных
import geopy.geocoders
from geopy.geocoders import Nominatim
geolocator = Nominatim(user_agent = input())
geopy.geocoders.options.default_timeout = 7

# библиотеки для визуализации карты

import folium
from folium import Map, Choropleth
from folium import Marker, Map
from folium.plugins import MarkerCluster
from folium.plugins import AntPath

# cброс ограничений на число столбцов
pd.set_option('display.max_columns', None)

# загрузка датасетов
players = pd.read_csv(
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3TtrPT83dPIbAEtp5tjhpHmllTxYjFhJ62lThCeI9yPMeYwMCHPq9J5uoAL-Zcx3HvxMlXEeEl8iT/pub?output=csv'
)
personal_data = pd.read_csv('https://raw.githubusercontent.com/CurasaoRG/hockey_project/main/players_personal_data.csv', parse_dates = ['Date_of_Birth'])
stats = pd.read_csv('https://docs.google.com/spreadsheets/d/e/2PACX-1vT411kwpQk6lUrapB4bnsC1--cUkQMxWieItZ0sfIoYdmsO50Lu_hWws-r_UBfaww/pub?output=csv')

# приведем название столбцов к нижнему регистру методом lower()

for df in [players, personal_data, stats]:
    df.columns = df.columns.str.lower()

"""### Датафрейм `players`

Изучим данные датафрейма `players` о игрoках и их командах
"""

# выведем первые 5 строчек датафрейма для ознакомления с исследуемыми данными
players.head(5)

# выведем основную информацию о датафреймах с помощью метода info()
players.info()

# выведем количество пропущенных значений для каждого столбца
players.isnull().sum()

# проверим наличие дубликатов в таблице
players.duplicated().sum()

# изменим тип данных для даты
players[['start_date', 'end_date']] = players[['start_date', 'end_date']].astype('datetime64[ns]')

players.head(5)

"""### Датафрейм `personal_data`

Изучим данные датафрейма `personal_data`
"""

# выведем первые 5 строчек датафрейма для ознакомления с исследуемыми данными
personal_data.head()

# выведем основную информацию о датафреймах с помощью метода info()
personal_data.info()

# проверим наличие дубликатов в таблице
personal_data.duplicated().sum()

"""### Датафрейм `stats`

Изучим данные датафрейма `stats`
"""

# выведем первые 5 строчек датафрейма для ознакомления с исследуемыми данными
stats.head()

# выведем основную информацию о датафреймах с помощью метода info()
stats.info()

# преобразуем тип данных для даты рождения хоккеиста

month_map = {
    'янв.': 'Jan', 'февр.': 'Feb', 'мар.': 'Mar', 'апр.': 'Apr',
    'мая': 'May', 'июн.': 'Jun', 'июл.': 'Jul', 'авг.': 'Aug',
    'сент.': 'Sep', 'окт.': 'Oct', 'нояб.': 'Nov', 'дек.': 'Dec'
}

stats['born'] = stats['born'].replace(month_map, regex=True)

stats['born'] = pd.to_datetime(stats['born'], format='%d-%b-%y')

# преобразуем тип данных для показателей хоккеиста
columns = ['%sog', 's/g', '%fo', 'sft/g', 'sfte/g', 'sftpp/g', 'sftsh/g', '%sv', 'gaa']

for i in columns:
    stats[i] = stats[i].str.replace(',', '.')
    stats[i] = stats[i].str.replace('-', '0')
    stats[i] = stats[i].astype(float)

stats.info()

# проверим наличие дубликатов в таблице
stats.duplicated().sum()

# заменим пропуски на 0
stats = stats.fillna(0)

"""### Подготовка данных

Для расчета числа Лемтюгова необходимо объединить таблицы, чтобы было представление об игроках и их сокомандниках в различные периоды времени.

В таблице `players` присутствуют необъодимие данные, следует добавить сезон по `start_date`, затем объединить таблицу с собой.

Начнем с проверки информации об игроках.
"""

print(f"Количество уникальных игроков по столбцу `player`: {players['player'].nunique()}")
print(f"Количество уникальных игроков по столбцу `player_link`: {players['player_link'].nunique()}")

"""Проверим наличие однофамильцев."""

players.groupby('player').agg({'player_link':'nunique'}).query('player_link> 1').sort_values(by='player_link', ascending=False).head(10)

"""Так как уникальных игроков по ссылке больше, чем игроков по имени, и подтверждено наличие однофамильцев, для удобства создадим для каждого хоккеиста `id` по его ссылке."""

players['id'] = players.player_link.str.split('/', expand=True)[4].astype(int)

# создадим отдельную таблицу с именем игрока и его `id`
players_id = players[['player', 'player_link', 'id']].drop_duplicates().reset_index(drop = True)

"""### Sankey Chart: визуализируем переходы между командами

Полезные ссылки на визуализацию:
* [ссылка 1](https://habr.com/ru/articles/566568/)
* [ссылка 1](https://plotly.com/python/sankey-diagram/)
"""

# выберем топ игроков по переходам
top_switchers = (
    players.groupby('id').agg(num_teams=('team', 'count'))
    .sort_values(by='num_teams', ascending=False).head(20).index

)

top_transfers = (
    players
    .query('id in @top_switchers')
    .sort_values(by=['id','start_date'])
)
top_transfers.head()

# преобразование исходной таблицы

def add_features(df):

    """Функция генерации новых столбцов для исходной таблицы

    Args:
        df (pd.DataFrame): исходная таблица.
    Returns:
        pd.DataFrame: таблица с новыми признаками.
    """

    # сортируем по id и времени
    sorted_df = df.sort_values(by=['id', 'start_date']).copy()
    # добавляем шаги предывания в разных командах
    sorted_df['step'] = sorted_df.groupby('id').cumcount() + 1

    # добавляем узлы-источники и целевые узлы
    # узлы-источники - это сами команды
    sorted_df['source'] = sorted_df['team']

    # добавляем целевые узлы
    sorted_df['target'] = sorted_df.groupby('id')['source'].shift(-1)

    # возврат таблицы без имени команды
    return sorted_df.drop(['team'], axis=1)

# преобразуем таблицу
table = add_features(top_transfers)
table.head()

# удалим все пары source-target, шаг которых превышает 7
# и сохраним полученную таблицу в отдельную переменную
df_comp = table[table['step'] <= 7].copy().reset_index(drop=True)

# создание словаря с индексами source

def get_source_index(df):

    """Функция генерации индексов source

    Args:
        df (pd.DataFrame): исходная таблица с признаками step, source, target.
    Returns:
        dict: словарь с индексами, именами и соответсвиями индексов именам source.
    """

    res_dict = {}

    count = 0
    # получаем индексы источников
    for no, step in enumerate(df['step'].unique().tolist()):
        # получаем уникальные наименования для шага
        res_dict[no+1] = {}
        res_dict[no+1]['sources'] = df[df['step'] == step]['source'].unique().tolist()
        res_dict[no+1]['sources_index'] = []
        for i in range(len(res_dict[no+1]['sources'])):
            res_dict[no+1]['sources_index'].append(count)
            count += 1

    # соединим списки
    for key in res_dict:
        res_dict[key]['sources_dict'] = {}
        for name, no in zip(res_dict[key]['sources'], res_dict[key]['sources_index']):
            res_dict[key]['sources_dict'][name] = no
    return res_dict

# создаем словарь
source_indexes = get_source_index(df_comp)

# функция случайной генерации цветов

def generate_random_color():

    """Случайная генерация цветов rgba

    Args:

    Returns:
        str: Строка со сгенерированными параметрами цвета
    """

    # сгенерим значение для каждого канала
    r, g, b = np.random.randint(255, size=3)
    return f'rgba({r}, {g}, {b}, 1)'

# создание словаря с соответствиями source: color

def colors_for_sources(mode):

    """Генерация цветов rgba

    Args:
        mode (str): сгенерировать случайные цвета, если 'random', а если 'custom' -
                    использовать заранее подготовленные
    Returns:
        dict: словарь с цветами, соответствующими каждому индексу
    """
    # словарь, в который сложим цвета в соответствии с индексом
    colors_dict = {}

    if mode == 'random':
        # генерим случайные цвета
        for label in df_comp['source'].unique():
            r, g, b = np.random.randint(255, size=3)
            colors_dict[label] = f'rgba({r}, {g}, {b}, 1)'

    elif mode == 'custom':
        # присваиваем ранее подготовленные цвета
        colors = requests.get('https://raw.githubusercontent.com/rusantsovsv/senkey_tutorial/main/json/colors_senkey.json').json()
        for no, label in enumerate(df_comp['source'].unique()):
            colors_dict[label] = colors['custom_colors'][no]

    return colors_dict

# генерю цвета из своего списка
colors_dict = colors_for_sources(mode='custom')

# расчет количества уникальных пользователей в процентах

def percent_users(sources, targets, values):

    """
    Расчет уникальных id в процентах (для вывода в hover text каждого узла)

    Args:
        sources (list): список с индексами source.
        targets (list): список с индексами target.
        values (list): список с "объемами" потоков.

    Returns:
        list: список с "объемами" потоков в процентах
    """

    # объединим источники и метки и найдем пары
    zip_lists = list(zip(sources, targets, values))

    new_list = []

    # подготовим список словарь с общим объемом трафика в узлах
    unique_dict = {}

    # проходим по каждому узлу
    for source, target, value in zip_lists:
        if source not in unique_dict:
            # находим все источники и считаем общий трафик
            unique_dict[source] = 0
            for sr, tg, vl in zip_lists:
                if sr == source:
                    unique_dict[source] += vl

    # считаем проценты
    for source, target, value in zip_lists:
        new_list.append(round(100 * value / unique_dict[source], 1))

    return new_list

# создание словаря с данными для отрисовки диаграммы

def lists_for_plot(source_indexes=source_indexes, colors=colors_dict, frac=0):

    """
    Создаем необходимые для отрисовки диаграммы переменные списков и возвращаем
    их в виде словаря

    Args:
        source_indexes (dict): словарь с именами и индексами source.
        colors (dict): словарь с цветами source.
        frac (int): ограничение на минимальный "объем" между узлами.

    Returns:
        dict: словарь со списками, необходимыми для диаграммы.
    """

    sources = []
    targets = []
    values = []
    labels = []
    link_color = []
    link_text = []

    # проходим по каждому шагу
    for step in tqdm(sorted(df_comp['step'].unique()), desc='Шаг'):
        if step + 1 not in source_indexes:
            continue

        # получаем индекс источника
        temp_dict_source = source_indexes[step]['sources_dict']

        # получаем индексы цели
        temp_dict_target = source_indexes[step+1]['sources_dict']

        # проходим по каждой возможной паре, считаем количество таких пар
        for source, index_source in tqdm(temp_dict_source.items()):
            for target, index_target in temp_dict_target.items():
                # делаем срез данных и считаем количество id
                temp_df = df_comp[(df_comp['step'] == step)&(df_comp['source'] == source)&(df_comp['target'] == target)]
                value = len(temp_df)
                # проверяем минимальный объем потока и добавляем нужные данные
                if value > frac:
                    sources.append(index_source)
                    targets.append(index_target)
                    values.append(value)
                    # делаем поток прозрачным для лучшего отображения
                    link_color.append(colors[source].replace(', 1)', ', 0.2)'))

    labels = []
    colors_labels = []
    for key in source_indexes:
        for name in source_indexes[key]['sources']:
            labels.append(name)
            colors_labels.append(colors[name])

    # посчитаем проценты всех потоков
    perc_values = percent_users(sources, targets, values)

    # добавим значения процентов для howertext
    link_text = []
    for perc in perc_values:
        link_text.append(f"{perc}%")

    # возвратим словарь с вложенными списками
    return {'sources': sources,
            'targets': targets,
            'values': values,
            'labels': labels,
            'colors_labels': colors_labels,
            'link_color': link_color,
            'link_text': link_text}

# создаем словарь
data_for_plot = lists_for_plot()

# создание объекта диаграммы

def plot_senkey_diagram(data_dict=data_for_plot):

    """
    Функция для генерации объекта диаграммы Сенкей

    Args:
        data_dict (dict): словарь со списками данных для построения.

    Returns:
        plotly.graph_objs._figure.Figure: объект изображения.
    """

    fig = go.Figure(data=[go.Sankey(
        domain = dict(
          x =  [0,1],
          y =  [0,1]
        ),
        orientation = "h",
        valueformat = ".0f",
        node = dict(
          pad = 50,
          thickness = 15,
          line = dict(color = "black", width = 0.1),
          label = data_dict['labels'],
          color = data_dict['colors_labels']
        ),
        link = dict(
          source = data_dict['sources'],
          target = data_dict['targets'],
          value = data_dict['values'],
          label = data_dict['link_text'],
          color = data_dict['link_color']
      ))])
    fig.update_layout(title_text="Sankey Diagram", font_size=10, width=3000, height=1200)

    # возвращаем объект диаграммы
    return fig

# сохраняем диаграмму в переменную
senkey_diagram = plot_senkey_diagram()

# отобразим диаграмму
senkey_diagram.show()

"""### Chord диаграмма:  визуализируем переходы игроков

Полезные ссылки для визуализации:
* [ссылка 1](https://holoviews.org/reference/elements/bokeh/Chord.html)

* [ссылка 2](https://holoviews.org/gallery/demos/bokeh/route_chord.html)

* [ссылка 3](https://faun.dev/c/stories/okanyenigun/create-a-chord-diagram-in-python/)

Сначала подготовим таблицу, необходимо добавить следующую команду, в которой играл хоккеист, поэтому поднимем команды на одну вверх в новом столбце и получим пары.
"""

# поднимаем следующую команду хоккеиста
top_transfers['team_2'] = top_transfers['team'].shift(-1)

# добавляем фильтр, чтобы были только команды игрока, а не поднималась команда следующего по таблице хоккеиста
top_transfers['player_2'] = top_transfers['player'].shift(-1)

top_transfers = top_transfers.query('player == player_2')

# для построения диаграммы нужны id команд, создадим их - выделим команды, пронумеруем их и добавим к датафрейму
tr_list = top_transfers['team'].unique().tolist()
tr_list_1 = np.arange(0, len(set(tr_list))).tolist()

set(tr_list)

keys = list(set(tr_list))
dic = {k: v for k, v in zip(keys, tr_list_1)}


# добавляем к датафрейму
top_transfers['id_team'] = top_transfers.team.map(dic)
top_transfers['id_team_2'] = top_transfers.team_2.map(dic)


# считаем количество переходов
transfers_count = top_transfers.groupby(['id_team', 'id_team_2']).start_date.count().reset_index()


# добавляем названия узлов
tms = pd.DataFrame.from_dict(dic, 'index').reset_index().rename(columns={'index': 'name', 0:'index'})
nodes = hv.Dataset(tms, 'index', 'name')

chord = hv.Chord((transfers_count, nodes), ['id_team', 'id_team_2'], ['start_date'])

chord.opts(
    opts.Chord(title='Переходы топ-20 игроков между командами',
               cmap='Category20', edge_cmap='Category20',
               edge_color=dim('id_team').str(),
               labels='name', node_color=dim('index').str()))

hv.extension('bokeh')
hv.output(size=300)
output_file('test.html')
show(hv.render(chord))

"""Визуализируем топ переходов между командами."""

# добавляем информацию о переходе игрока из одной команды в другую
top_trs = add_features(players.sort_values(by=['id', 'start_date'])).dropna()

# расчет количества переходов
top_trs = top_trs.groupby(['source', 'target'], as_index=False)['id'].count().sort_values(by='id', ascending=False).rename(columns={'id':'num_players'})

# оставляем тоg-50
top_trs = top_trs.query('source != target')[:50]

# добавляем `id` по команде
top_trs['id_source'] = top_trs['source'].map(dic)
top_trs['id_target'] = top_trs['target'].map(dic)
top_trs.head()

# создаем датасет с узлами - это уникальные id и названия команд
trs_nodes = pd.concat([
    top_trs[['id_source', 'source']].rename(columns={'id_source': 'id', 'source': 'team'}),
    top_trs[['id_target', 'target']].rename(columns={'id_target': 'id', 'target': 'team'})
], ignore_index=True, axis=0).drop_duplicates()

# чтобы график построился, передаем узлы в holoview
nodes = hv.Dataset(trs_nodes, 'id', 'team')

# и строим диаграмму - передаем ребра (связь - откуда - куда) и узлы (названия команд), num_players - как бы "ширина" ребра, сколько переходов было
chord = hv.Chord((top_trs, nodes), ['id_source', 'id_target'], ['num_players'])

chord.opts(
    opts.Chord(title='Топ-50 переходов между командами',
               cmap='Category20', edge_cmap='Category20',
               edge_color=dim('id_source').str(),
               labels='team',
               node_color=dim('id').str()))

hv.extension('bokeh')
hv.output(size=300)
output_file('test.html')
show(hv.render(chord))

"""### Поиск одноклубников

Объединим таблицу `players` саму с собой по полям наименования команды. Исключаем записи игрока к самому себе. Также, учитывая различное время пребывания в команде игроков, в правой части таблицы оставляем только тех игроков, которые пришли раньше ухода левого, и ушли позже прихода левого.
"""

players.head()

# объединяем таблицу с собой
df_players= (
    players[['id', 'player', 'team', 'start_date', 'end_date']]
    .merge(players[['id', 'player', 'team', 'start_date', 'end_date']],
           on = 'team',
           how='left')
    )

# очищаем таблицу от лишних записей
df_players = df_players.query('id_x != id_y & start_date_x <= end_date_y & start_date_y <= end_date_x')

df_players.head()

"""### Статистика трансферов по хоккеистам

Расмотрим различные показатели по переходам игроков в командах.

Сколько переходов между командами КХЛ совершили игроки.
"""

# количество всех различных команд в разные сезоны, за коротые приходилось играть хоккеисту, равноценно количеству переходов
players.groupby(['id', 'player']).agg(count_team=('team', 'count')).sort_values(by='count_team', ascending=False).head(10)

"""Посмотрим на количество переходов для Николая Лемтюгова."""

# число переходов для Лемтюгова
players.query('player == "Nikolai Lemtyugov"').groupby(['id', 'player']).agg(count_team=('team', 'count'))

"""Также посмотрим сколько разных клубов сменили игроки за это время. Т.к. команда в разные сезоны состоит из разных игроков, соответственно и пребывание в разные сезоны прибавляет количество одноклубников, а клуб он один и постоянный, как например СКА Санкт-Петербург."""

# количество уникальных клубов лиги КХЛ для игрока
players.groupby(['id', 'player']).agg(count_team=('team', 'nunique')).sort_values(by='count_team', ascending=False).head(10)

"""Наибольшее количество команд, 11, сменили 3 хоккеиста, а Николай Лемтюгов побывал в 10 разных командах, и совершил 11 переходов, соответственно он имеет не самое большое количество одноклубников.


Посмотрим тогда, кто имеет наибольшее количество одноклубников по играм в КХЛ.
"""

# количество одноклубников для хоккеиста за его игры в разных командах
df_players.groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique')).sort_values(by='count_player', ascending=False).head(10)

# количество одноклубников Николая
df_players.query('player_x == "Nikolai Lemtyugov"').groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique'))

"""Количество одноклубников для Николая Лемтюгова 357 и он не входит в топ-10 игроков по количеству, можем предположить тот факт, что Николай совершал меньше переходов и возможно на более длительный срок оставался в команде, или играл в команде с сильными игроками, которые не так часто сменялись, за счет того что клуб не хочет их продавать.

Также можно посмотреть статистику по командам. Какие команды имели в своем арсенале большее количество игроков.
"""

# количество сменяемых игроков в команде
players.groupby('team').agg(count_player=('id', 'count')).sort_values(by='count_player', ascending=False).head(10)

# количество хоккеистов, хоть раз игравших в команде
players.groupby('team').agg(count_player=('id', 'nunique')).sort_values(by='count_player', ascending=False).head(10)

"""Команды `Амур`, `Спартак`, `Нефтехимик`, `Торпедо` и `Витязь` занимают первые позиции по количеству хоккеистов. Возможно есть причины, по которым там не хочется играть.

## Расчет числа Лемтюгова

### Алгоритм расчета числа Лемтюгова

Полезные сслылки для работы с графами:
* [ссылка 1](https://www.pythonforbeginners.com/data-structures/shortest-path-length-from-a-vertex-to-other-vertices-in-a-graph)

* [ссылка 2](https://pimiento.github.io/python_graphs.html)
"""

# составляем граф, где каждому игроку, соответствуют его сокомандники
df_graph = df_players.groupby('id_x').agg({'id_y':'unique'}).reset_index()

graph = df_graph.set_index("id_x").id_y.to_dict()

"""Прописываем функцию для поиска по графу кратчайшего пути между вершинами."""

# поиск кратчайшего пути по графу для кaждого значения до source
def calculate_distance(input_graph, source):
    Q = Queue()
    distance_dict = {k: 999999999 for k in input_graph.keys()}
    visited_vertices = list()
    Q.put(source)
    visited_vertices.append(source)
    while not Q.empty():
        vertex = Q.get()
        if vertex == source:
            distance_dict[vertex] = 0
        for u in input_graph[vertex]:
            if u not in visited_vertices:
                # update the distance
                if distance_dict[u] > distance_dict[vertex] + 1:
                    distance_dict[u] = distance_dict[vertex] + 1
                Q.put(u)
                visited_vertices.append(u)
    return distance_dict

"""Создадим словать с помощью функции, где для каждого хоккеиста будет путь до Лемтюгова Николая"""

def calculate_number(input_graph, source):
    # поиск `id`
    id = players_id.query('player == @source').reset_index().loc[0, 'id']

    # поиск кратчайшего пути по графу для кaждого значения до source
    distances = calculate_distance(input_graph, id)

    # преобразование словаря в датафрейм
    number = pd.DataFrame.from_dict(distances, orient='index').reset_index().rename(columns={'index': 'id', 0: 'number'})

    # добавление имени игрока
    number = number.merge(players_id[['player', 'id']], left_on='id', right_on='id', how='left')

    # меняем порядок столбцов и сортируем по числу в порядке убывания
    number = number[['id', 'player', 'number']]
    number = number.sort_values(by='number', ascending=False)

    return number

lemtyugov_number = calculate_number(graph, "Nikolai Lemtyugov")

lemtyugov_number.head()

lemtyugov_number['number'].agg(['mean', 'median'])

"""Т.о. выходит, что игроки таблицы `players` по командам лиги КХЛ максимум в трех рукопожатиях от Николая Лемтюгова. Также не представлено игроков, которые бы не имели числа Лемтюгова, т.е. совсем не связанных с ним через сокомандников.

Можно проверить, какое будет максимальное число, расчитанного от игрока с самым большим и самым малым числом сокомандников.

### Альтернативные расчеты чисел других хоккеистов

**Расчет числа игрока с наибольшим количеством одноклубников**
"""

# количество одноклубников для хоккеиста за его игры в разных командах
player_max = (
    df_players.groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique'))
    .sort_values(by='count_player', ascending=False).head(1)
    .reset_index().loc[0, 'player_x']
)

player_max

player_max_number = calculate_number(graph, player_max)

player_max_number.head()

player_max_number['number'].agg(['mean', 'median'])

"""**Расчет числа игрока с наименьшим количеством одноклубников**"""

# количество одноклубников для хоккеиста за его игры в разных командах
player_min = (
    df_players.groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique'))
    .sort_values(by='count_player', ascending=True).head(1)
    .reset_index().loc[0, 'player_x']
)

player_min

player_min_number = calculate_number(graph, player_min)

player_min_number.head()

player_min_number['number'].agg(['mean', 'median'])

"""**Расчет числа игрока с наибольшим количеством переходов по командам**"""

# количество переходов для хоккеиста
team_max = (
    players.groupby(['id', 'player']).agg(count_team=('team', 'count'))
    .sort_values(by='count_team', ascending=False).head(1)
    .reset_index().loc[0, 'player']
)

team_max

team_max_number = calculate_number(graph, team_max)

team_max_number.head()

team_max_number['number'].agg(['mean', 'median'])

"""**Расчет числа игрока с наименьшим количеством переходов по командам**"""

# количество переходов для хоккеиста
team_min = (
    players.groupby(['id', 'player']).agg(count_team=('team', 'count'))
    .sort_values(by='count_team', ascending=True).head(1)
    .reset_index().loc[0, 'player']
)

team_min

team_min_number = calculate_number(graph, team_min)

team_min_number.head()

team_min_number['number'].agg(['mean', 'median'])

"""Для самого богатого на одноклубников хоккеиста и частого по переходам также максимальное число равно 3. Медиана в двух рукопожатиях, среднее меньше, чем по числу Лемтюгова на четыре и одну сотых соответственно. т.е. для Лемтюгова больше хоккеистов, имеющих больше двух рукопожатия.

Для игроков с наименьшим количеством одноклубников и меньшим количеством переходов максимальное число составило 4.

### Визуализация графа

Полезные ссылки для визуализации графа:
* [ссылка 1](https://networkx.org/documentation/stable/index.html)
* [ссылка 2](https://habr.com/ru/companies/ruvds/articles/705368/)
* [ссылка 3](https://plotly.com/python/network-graphs/)
* [ссылка 4](https://holoviews.org/user_guide/Network_Graphs.html)
"""

df_vis = df_players[['id_x',	'player_x',	'id_y',	'player_y']]

"""Найдем 50 хоккеистов с наибольшим количеством сокомандников."""

top_id = df_vis.groupby(['id_x'])['id_y'].nunique().sort_values(ascending=False).head(50).index.to_list()
top_ids = df_vis.query('id_x in @top_id')

# cоздаем лист для изменения расчета расстояний между элементами - он нам понадобится, если захотим применить метод расчета расстояний shell_layout
rp = top_ids.groupby('player_x').agg({'player_y': 'unique'})['player_y'].to_dict()
for k, v in rp.items():
    rp[k] = v.tolist()

lst = []
for i, v in zip(top_id, rp.values()):
    lst.append([i])
    lst.append(v)

# создаем граф из таблицы pandas по библиотеке Networks, метод from_pandas_edgelist
G = nx.from_pandas_edgelist(top_ids, 'player_x', 'player_y')

# можем изменить внешний вид визуализации, если поменяем способ расчета расстояний
pos = nx.spring_layout(G)

G

# добавляем атрибут с информацией по расположению узлов
for node in G.nodes:
    G.nodes[node]['pos'] = list(pos[node])

"""Вот так выглядят первые 5 узлов (nodes) в нашем графе."""

list(G.nodes(data=True))[0:5]

edge_x = []
edge_y = []
for edge in G.edges():
    x0, y0 = G.nodes[edge[0]]['pos']
    x1, y1 = G.nodes[edge[1]]['pos']
    edge_x.append(x0)
    edge_x.append(x1)
    edge_x.append(None)
    edge_y.append(y0)
    edge_y.append(y1)
    edge_y.append(None)

edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=0.5, color='#888'),
    hoverinfo='none',
    mode='lines')

node_x = []
node_y = []
for node in G.nodes():
    x, y = G.nodes[node]['pos']
    node_x.append(x)
    node_y.append(y)

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers',
    hoverinfo='text',
    marker=dict(
        showscale=True,
        # colorscale options
        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
        colorscale='Hot',
        reversescale=True,
        color=[],
        size=10,
        colorbar=dict(
            thickness=15,
            title='Node Connections',
            xanchor='left',
            titleside='right'
        ),
        line_width=2))

node_adjacencies = []
node_text = []
for node, adjacencies in enumerate(G.adjacency()):
    node_adjacencies.append(len(adjacencies[1]))
    node_text.append('player: '+str(adjacencies[0])+ ' ' + '# of connections: '+str(len(adjacencies[1])))

node_trace.marker.color = node_adjacencies
node_trace.text = node_text

fig = go.Figure(data=[edge_trace, node_trace],
             layout=go.Layout(width=1200, height=1200,
                title='Граф топ-50 игроков и их связей',
                titlefont_size=16,
                showlegend=False,
                hovermode='closest',
                margin=dict(b=20,l=5,r=5,t=40),
                annotations=[ dict(
                    text="",
                    showarrow=False,
                    xref="paper", yref="paper",
                    x=0.005, y=-0.002 ) ],
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                )
fig.show()

"""**Визуализация графов с помощью Holoview**

"""

kwargs = dict(width=800, height=800, xaxis=None, yaxis=None)
opts.defaults(opts.Nodes(**kwargs), opts.Graph(**kwargs))

colors = ['#000000']+hv.Cycle('Category20').values

graph = hv.Graph.from_networkx(G, pos)

graph.opts(cmap=colors, node_size=5, edge_line_width=1,
              node_line_color='gray')

hv.extension('bokeh')
hv.output(size=100)
output_file('test.html')
show(hv.render(graph))

bundled = bundle_graph(graph)

hv.extension('bokeh')
hv.output(size=100)
output_file('test.html')
show(hv.render(bundled))

"""## Проверка гипотез

### Гипотеза 1: Лемтюгов – самый популярный хоккеист в лиге, то есть обладающий самым большим количеством одноклубников

Расчитаем количество одноклубников по хоккеистам и выведем ТОП-15.
"""

# ТОП-15 хоккеистов по количеству одноклубников
df_players.groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique')).sort_values(by='count_player', ascending=False).head(15)

# количество одноклубников Николая
df_players.query('player_x == "Nikolai Lemtyugov"').groupby(['id_x', 'player_x']).agg(count_player=('id_y','nunique'))

"""**Гипотеза о том, что Николай Лемтюгов является самым популярным хоккеистов неверна.**

Николай Лемтюгов не оказался самым популярным среди хоккеистов, у него 357 одноклубников, и он не входит в ТОП-15. Самым же популярным является Евгений Лапенков, ему удалось сыграть совместно в 475 игроками.

### Гипотеза 2: Игроки с низким значением числа Лемтюгова играли в среднем в большем количестве команд, чем игроки, у которых это значение больше

Посмотрим какое распределение игроков по числу Лемтюгова.
"""

lemtyugov_number.groupby('number').agg({'id':'nunique'})

# получим таблицу с количеством команд и числом Лемтюгова для каждого хоккеиста
players_team = players.groupby(['id', 'player']).agg(count_team=('team', 'count')).reset_index()

df_hip2 = players_team.merge(lemtyugov_number, on=['id', 'player'], how='left')

df_hip2.head()

"""Выведем среднее значение команд для каждого числа Лемтюгова."""

df_hip2.groupby('number').agg(mean_count_team=('count_team', 'mean'))

"""Т.о. без дополнительных проверок можно сказать, что чем больше команд сменил игрок, тем меньше растояние до Лемтюгова, т.е. меньше число. К примеру игроки, побывавшие только в одной команде, имеют число 3. Возможно это еще совсем юные игроки и в будущем их растояние до лемтюгова изменится.


**Гопотеза о том, что чем меньше число Лемтюгова у хоккеиста, тем в среднем он сменил больше команд подтверждена.**

### Гипотеза 3: Существет связь между количеством переходов и ростом/весом игрока (предполагаем, что игроки, у которых рост выше, лучше играют в хоккей и соответственно чаще переходят из клуба в клуб)

Для проверки гипотезы, создадим новую таблицу, взяв данные о росте и весе игрока из таблицы `stats` и присоединим данные о количестве переходов. Можно использовать таблицу для присоединения из предыдущего пункта.
"""

# объединяем игроков с количеством команд с данными по их весу и росту
# для начала добавим id хоккеисту в таблице stats


df_hip3 = df_hip2.merge(
    stats[['player', 'player_link', 'hight', 'weight']].merge(players_id,
                                                              on=['player', 'player_link'],
                                                              how='left'),
    on=['id', 'player'],
    how='left'
)

# распределение среднего роста по количеству переходов
df_hip3.groupby('count_team').agg({'hight':'mean', 'weight':'mean'}).reset_index().plot(
    y='hight', x='count_team', grid=True,
    figsize=(8, 4))
plt.xlabel('Количество команд')
plt.ylabel('Рост игрока');

# распределение среднего веса по количеству переходов
df_hip3.groupby('count_team').agg({'hight':'mean', 'weight':'mean'}).reset_index().plot(
    y='weight', x='count_team', grid=True,
    figsize=(8, 4))
plt.xlabel('Количество команд')
plt.ylabel('Вес игрока');

"""Сначала можем утверждать, что по мере увеличения массы игрока увеличивается и количество команд, в которых он играл, но эта тенденция прослеживается до 8 переходов, затем зависимость не соблюдается. К тому же в данном случае (с весом) будет логично утверждать, что связь скорее с возрастом: если юный игрок приходит в команду с меньшим весом, то по мере его взросления масса увечичивается, как и его опыт игры в различных командах.

В отношении среднего роста по количеству команд не наблюдается какой либо связи.
"""

# построим матрицу диаграмм рассеяния и выведем коэффициенты корреляци
sns.pairplot(df_hip3[['count_team', 'hight', 'weight']])
plt.gcf().set_size_inches(9,9);
df_hip3[['count_team', 'hight', 'weight']].corr()

"""В данном случае можно наблюдать только связь между ростом и весом, что вполне логично, чем выше спортсмен, тем больше мышечной массы и больше вес. А вот явной связи с числом команд/переходов нет, самые высокие игроки были менее чем в 6 командах.

Допустим, что у нас есть игроки, которые недавно пришли и мало играли (соответственно мало переходов), также как есть и хоккеисты которые рано ушли. Для примера отделим игроков, которые играли определенный период.
"""

# `id` игроков с первой датой в команде не позже 2010 года
id_hip3_1 = players.groupby('id').agg({'start_date':'min'}).query('start_date < "2010-12-31"').index

# `id` игроков с последней датой в команде не раньше 2020 года
id_hip3_2 = players.groupby('id').agg({'end_date':'max'}).query('end_date > "2020-12-31"').index

df_hip3_2 = df_hip3.query('id in @id_hip3_1 and id in @id_hip3_2')

# построим матрицу диаграмм рассеяния и выведем коэффициенты корреляци
sns.pairplot(df_hip3_2[['count_team', 'hight', 'weight']])
plt.gcf().set_size_inches(8,8);
df_hip3_2[['count_team', 'hight', 'weight']].corr()

"""В таком случае корреляции между ростом/весом и количеством переходом практически нет.

**Гопотеза о том, что существует связть между количеством переходов и ростом/весом игрока не подтверждена.**

### Гипотеза 4: Существует связь между местом рождения игрока и его успехами (предполагаем, что жители северных городов - более успешные хоккеисты)

Для ответа на эту гипотезу построим карту, на которой будут отмечены места рождения успешных игроков и сравним, относятся ли они к северным или нет.

В данном случае будем определять успешность игрока от количества полученных им наград. Для этого создадим функцию, которая подсчитает количество наград, находящихся в словаре столбца `awards` таблицы `personal_data`.
"""

# добавляем `id` для игрока
personal_data['id'] = personal_data.player_link.str.split('/', expand=True)[4].astype(int)

def data_of_players(df):

    # пустая таблица для записи данных
    new_data = pd.DataFrame({
       'id': [], # id игрока
       'place': [], # место рождения
       'count_of_awards': [] # количество наград
    })

    for i in df['id'].unique():

        id_i = i

        df_i = df.query('id == @id_i').reset_index()

        place_of_birth_i = df_i.loc[0, 'place_of_birth']

        awards_i = eval(df_i.loc[0, 'awards'])
        count_of_awards_i = len(list(awards_i.values()))

        # дабавляем в таблицу запись об используемых услугах за месяц

        new_data.loc[len(new_data.index)] = [id_i, place_of_birth_i, count_of_awards_i]

    return new_data

# передаем функции таблицу с данными хоккеистов
df_hip4 = data_of_players(personal_data)

df_hip4.head()

"""Посмотрим на распределение хоккеистов по количеству наград."""

df_hip4.groupby('count_of_awards').agg({'id':'nunique'})

# смотрим на описание распределения
df_hip4.groupby('count_of_awards', as_index=False).agg({'id':'nunique'})['count_of_awards'].describe()

"""Большинство хоккеистова имеют не более 6 наград."""

print(f"Количество хоккеистов с количеством наград не более шести: "
      f"{df_hip4.groupby('count_of_awards').agg({'id':'nunique'}).reset_index().query('count_of_awards <= 6')['id'].sum()}")
print()
print(f"Количество хоккеистов с количеством наград более шести: "
      f"{df_hip4.groupby('count_of_awards').agg({'id':'nunique'}).reset_index().query('count_of_awards > 6')['id'].sum()}")

"""Можем принять за более успешных хоккеистов тех, у которых количество наград более шести.

Теперь определим координаты городов для визуализации на карте.
"""

# функция для определения координат по названию места рождения

def geodata_of_players(geo_list):

    # пустая таблица для записи данных
    geodata = pd.DataFrame({
       'place': [], # место рождения
       'latitude': [], # широта
       'longitude': [] # долгота
    })

    for i in geo_list:

        location = geolocator.geocode(i, exactly_one=True, timeout=100)

        if location is not None:
            try:
                lat = location.latitude
                lon = location.longitude
            except:
                lat = 0
                lon = 0
        # дабавляем в таблицу запись об используемых услугах за месяц
            geodata.loc[len(geodata.index)] = [i, lat, lon]

    return geodata

# создаем список городов, в которых родились хоккеисты
geo_list = list(df_hip4.query('count_of_awards > 6')['place'].unique())

# передаем функции список городов #2/38
df_geo = geodata_of_players(geo_list)

df_geo.head()

# объединим таблицы с наградами и координатами городов
df_hip4 = df_hip4.query('count_of_awards > 6').merge(df_geo, on = 'place', how='left')

df_hip4.head()

"""Для некоторых городов не определились координаты, проверим сколько таких, и хватает ли данных для определения гипотезы."""

df_hip4.query('latitude == latitude')['id'].count()

df_hip4.query('latitude == latitude')['place'].nunique()

"""Проверим гипотезу на 311 успешных игроках в 107 различных местаж проживания."""

# для визуализации карты избавимся от пропусков
df_hip4 = df_hip4.dropna()

# центром карты ставим Москву
# moscow_lat - широта центра Москвы, moscow_lng - долгота центра Москвы
moscow_lat, moscow_lng = 55.751244, 37.618423

# создаём карту Москвы
m = Map(location=[moscow_lat, moscow_lng], zoom_start=2)

# создаём пустой кластер, добавляем его на карту
marker_cluster = MarkerCluster().add_to(m)

# пишем функцию, которая принимает строку датафрейма,
# создаёт маркер в текущей точке и добавляет его в кластер marker_cluster
def create_clusters(row):
    Marker(
        [row['latitude'], row['longitude']],
        popup=f"{row['place']}",
    ).add_to(marker_cluster)

"""Если посмотри на координаты [северных городов/поселений](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81%D0%B0%D0%BC%D1%8B%D1%85_%D1%81%D0%B5%D0%B2%D0%B5%D1%80%D0%BD%D1%8B%D1%85_%D0%BF%D0%BE%D1%81%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9_%D0%B2_%D0%BC%D0%B8%D1%80%D0%B5),то они определяются с 70'й широты. В России же принято считать [Санкт-Петербург](https://www.gov.spb.ru/helper/day/#:~:text=%D0%A1%D0%B0%D0%BD%D0%BA%D1%82%E2%80%91%D0%9F%D0%B5%D1%82%D0%B5%D1%80%D0%B1%D1%83%D1%80%D0%B3%20%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%20%D1%83%20%D0%B2%D0%BE%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B9,30%C2%B0%2019'%20%D0%B2%D0%BE%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B9%20%D0%B4%D0%BE%D0%BB%D0%B3%D0%BE%D1%82%D1%8B.) северным городом, а он находится на широте 59', поэтому возьмем за ориентир 59'ю широту и отобразим ее на карте."""

df_hip4.apply(create_clusters, axis=1)
north_lat = 59
# добавляем тточки для построения широты
pathLatLngs = [(north_lat, 1), (north_lat, 60), (north_lat, 120), (north_lat, 180),(north_lat, -60), (north_lat, -120), (north_lat, -180)]

# добавляем линию широты на карту
AntPath(pathLatLngs, color="red", weight=3).add_to(m)

m

# количество игроков рожденных выше 59' широты
df_hip4.query('latitude >= 59')['id'].count()

"""Итого, у нас 29 из рассматриваемых 311 успешных игроков родились в северных городах, т.е. менее 10%. В данном случае мы не можем подтвердить гипотезу.

К примеру мы выбрали неверную широту, т.к. и Канаду называют северной страной, и применимо к ней следует взять широту ниже. К примеру возьмем широту по озеру [Osoyoos](https://ru.db-city.com/%D0%9A%D0%B0%D0%BD%D0%B0%D0%B4%D0%B0--%D0%91%D1%80%D0%B8%D1%82%D0%B0%D0%BD%D1%81%D0%BA%D0%B0%D1%8F-%D0%9A%D0%BE%D0%BB%D1%83%D0%BC%D0%B1%D0%B8%D1%8F--%D0%9E%D0%BA%D0%B0%D0%BD%D0%B0%D0%B3%D0%B0%D0%BD-%D0%A1%D0%B8%D0%BC%D0%B8%D0%BB%D0%BA%D0%B0%D0%BC%D0%B8%D0%BD--Osoyoos), находящемся на границе Канады и США, широта 49'.
"""

# количество игроков рожденных выше 49' широты
df_hip4.query('latitude >= 49')['id'].count()

north_lat = 49
# добавляем тточки для построения широты
pathLatLngs = [(north_lat, 1), (north_lat, 60), (north_lat, 120), (north_lat, 180),(north_lat, -60), (north_lat, -120), (north_lat, -180)]

# добавляем линию широты на карту
AntPath(pathLatLngs, color="blue", weight=3).add_to(m)

m

"""В таком случае происходит несоответствие в евразийских странах, т.к. в эту широту попадает и Казахстан, который не относится к северной территории. Поэтому даже если мы добавим к 23 игрокам северных городов, по широте 59, 17 хоккеистов из Канады, также не сможем подтвердить гипотезу.

**Гипотеза о том, что существует связь, между местом рождения хоккеиста и его успехами, т.е. уроженцы северных городов более успешны, не подтверждена.**

### Гипотеза 5: Наиболее успешные хоккеисты рождаются в период с января по март

Для проверки данной гипотезы рассмотрим успешность игроков по их показателям в игре.
"""

# создаем таблицу для работы над гипотезой и добавляем месяц рождения хоккеиста
df_hip5 = stats.copy()

df_hip5['month'] = df_hip5['born'].dt.month

# добавляем `id` для игрока
df_hip5['id'] = df_hip5.player_link.str.split('/', expand=True)[4].astype(int)

# для удобства переименуем столбцы
df_hip5 = df_hip5.rename(columns={'+': 'plus', '-': 'minus'})

"""Можно рассмотреть успешность игроков по их личным заслугам в игре в зависимости от амплуа."""

# позиции в команде
df_hip5['position'].unique()

"""Представлены три позиции в игре, для каждой выделим ключевой [показатель](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D0%BA%D0%BA%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0):

forward:
- `+` (количество заброшенных шайб в то время, когда игрок находился на льду)
- `g` (количество забитых голов)
- `gwg` (победные голы - решающие голы, например третий гол победителя при счёте 2:2)


goaltender:
- `ga` (количество пропущенных)
- `%sv` (процент отраженных бросков)
- `l` (проигрыши / поражения)

defense:
- `hits` (физическое воздействие на соперника (в рамках правил), целью которого является отбор шайбы)
- `bls` (Бросок в хоккее с шайбой, накрытый или отбитый защитой до того, как шайба долетит до вратаря)
- `-` (количество пропущенных  шайб в то время, когда игрок находился на льду).


"""

# списки показателей по позициям
point_forward = ['plus', 'g', 'gwg']
point_goaltender = ['ga', '%sv', 'l']
point_defense = ['hits', 'bls', 'minus']

"""Создадим таблицу с количеством игроков на каждой позиции. В число успешных игроков отберем 20% из каждой позиции по итоговому показателю его эффективности."""

# таблица с кличеством игроков в каждой позиции
df_position = df_hip5.groupby('position').agg(count_pl=('id','nunique')).reset_index()

# количество игрокойв позиции относительно всех
df_position['of_all'] = round(df_position['count_pl']/df_position['count_pl'].sum()*100,2)

# количество игроков в статистуку успешных
df_position['count_best'] = round(df_position['count_pl']*0.2).astype(int)

df_position

"""Создадим функцию для определения оценки игрока по показателю эффективности. Функции будет передаваться таблица игроков одной позиции и список показателей эффективности.

Рассмотрим распределение показателей.
"""

# распределение показателей
(
    df_hip5.query('position == "forward"')[['plus', 'g', 'gwg']].describe(),
    df_hip5.query('position == "goaltender"')[['ga', '%sv', 'l']].describe(),
    df_hip5.query('position == "defense"')[['hits', 'bls', 'minus']].describe()
)

"""Учитываем, что для некоторых показателей хороший результат это минимум, например количество пропущенных мячей для вратаря.

Выставлять оценки для показателей 'plus', 'g', 'gwg', '%sv', 'hits', 'bls' будем в следующем расчете:
* менее 30 процентиля - оценка `1`;
* от 30 до 60 процентиля - оценка `2`;
* от 60 до 80 процентиля - оценка `3`;
* от 80 до 95 процентиля - оценка `4`;
* более 95 процентиля - оценка `5`.

Выставлять оценки для показателей 'ga', 'l', 'minus' будем в следующем расчете:
* более 60 процентиля - оценка `1`;
* от 50 до 60 процентиля - оценка `2`;
* от 40 до 50 процентиля - оценка `3`;
* от 25 до 40 процентиля - оценка `4`;
* менее 25 процентиля - оценка `5`.
"""

# функция для выставления оценок

def players_points(df, points):

    # пустая таблица для записи данных
    new_data = pd.DataFrame({
       'id': [], # id игрока
       'position': [], # позиция игрока
       'point_1': [], # оценка 1
       'point_2': [], # оценка 2
       'point_3': [] # оценка 3
    })

    # функция оценки, принимает столбец со всеми значениями показателя (y)
    # имя показателя и значение показателя для игрока (x)
    def mark(name, y, x):

        if name in ['plus', 'g', 'gwg', '%sv', 'hits', 'bls']:

            # присуждение оценки
            if x < np.percentile(y, 95):
                p = 4
                if x < np.percentile(y, 80):
                    p = 3
                if x < np.percentile(y, 60):
                    p = 2
                if x < np.percentile(y, 30):
                    p = 1
            else:
                p = 5

        elif name in ['ga', 'l', 'minus']:

            if x > np.percentile(y, 25):
                p = 4
                if x > np.percentile(y, 40):
                    p = 3
                if x > np.percentile(y, 50):
                    p = 2
                if x > np.percentile(y, 60):
                    p = 1
            else:
                p = 5
        # возвращаем оценку
        return p


    position = df.loc[0, 'position']

    # проходим по каждому хоккеисту
    for i in df['id'].unique():

        points_i = []

        # оставляем данные хоккеиста
        df_i = df.query('id == @i').reset_index()

        for j in range(3):

            # значение первого показателя для игрока
            x = df_i.loc[0, points[j]]
            y = df[points[j]]
            points_i.append(mark(points[j], y, x))


        # дабавляем в таблицу запись об оценках хоккеиста
        new_data.loc[len(new_data.index)] = [i, position, points_i[0], points_i[1], points_i[2]]

    # выводим общий показатель эффективности от суммы оценок
    new_data['sum_points'] = new_data['point_1'] + new_data['point_2'] + new_data['point_3']

    # сортируем таблицу по убывынию общего показателя
    new_data = new_data.sort_values(by='sum_points', ascending=False)

    return new_data

"""**Таблица для нападающих с оценками**"""

forward_points = players_points(df_hip5.query('position == "forward"').reset_index(), point_forward)

forward_points.head(5)

"""**Таблица для вратарей с оценками**"""

goaltender_points = players_points(df_hip5.query('position == "goaltender"').reset_index(), point_goaltender)

goaltender_points.head()

"""**Таблица для защитников с оценками**"""

defense_points = players_points(df_hip5.query('position == "defense"').reset_index(), point_defense)

defense_points.head()

"""Теперь выберем самых успешных игроков в каждой позиции, объединим их в список."""

# количество успешных берем в соответствии с рассчитанным числом 20% от всех по позиции

success_players = (
    list(forward_points['id'].head(df_position.loc[0, 'count_best'])) +
    list(goaltender_points['id'].head(df_position.loc[1, 'count_best'])) +
    list(defense_points['id'].head(df_position.loc[2, 'count_best']))
)

# оставляем в таблице только успешных игроков
df_hip5_1 = df_hip5.query('id in @success_players')

"""Теперь у нас готова таблица для рассмотрения количества успешных хоккеистов по месяцу рождения. Можем построить диграмму и визуально отследить, есть ли связь между месяцем рождения и успехом."""

# подготавливаем таблицу для визуализации
df_hip5_1_month = df_hip5_1.groupby('month').agg({'id':'nunique'}).sort_values(by='month').reset_index()

# строим столбчатую диаграмму
plt.figure(figsize=(10,6))
sns.barplot(x='month', y='id', data=df_hip5_1_month, palette='Blues')

# добавление меток с числом хоккеистов
for i, val in enumerate(df_hip5_1_month['id'].values):
    plt.text(i, val, int(val), horizontalalignment='center', verticalalignment='bottom', fontdict={'fontweight':500, 'size':12})

plt.xlabel('Месяц рождения')
plt.ylabel('Количество успешных хоккеистов')

plt.show()

"""Можно утверждать, что в первую половину года, с января по май, рождается большая часть успешных хоккеистов.  Утверждать по январю февралю с этими данными не можем, т.к. в первые два месяца родилось меньше хоккеистов, чем в март, апрель.

Посмотрим на распределение "неуспешных" хоккеистов.
"""

# таблица с неуспешными по оценкам хоккеистами
df_hip5_2 = df_hip5.query('id not in @success_players')
# подготавливаем таблицу для визуализации
df_hip5_2_month = df_hip5_2.groupby('month').agg({'id':'nunique'}).sort_values(by='month').reset_index()

# строим столбчатую диаграмму
plt.figure(figsize=(10,6))
sns.barplot(x='month', y='id', data=df_hip5_2_month, palette='Blues')

# добавление меток с числом хоккеистов
for i, val in enumerate(df_hip5_2_month['id'].values):
    plt.text(i, val, int(val), horizontalalignment='center', verticalalignment='bottom', fontdict={'fontweight':500, 'size':12})

plt.xlabel('Месяц рождения')
plt.ylabel('Количество неуспешных хоккеистов')

plt.show()

"""Для "неуспешных" хоккеистов больше подходит гипотеза, при том что январских хоккеистов больше всего, феврильские и мартовские не сильно превышают по соседним месяцам. В данном случае тажк можно предположить, что большая часть хоккеистов рождается в первую половину года. Соответственно и в общем объеме хоккеистов будет наблюдаться тенденция, что основаная часть хоккеистов рождается в первую половину года."""

# подготавливаем таблицу по всем хоккеистам
df_hip5_month = df_hip5.groupby('month').agg({'id':'nunique'}).sort_values(by='month').reset_index()
# строим столбчатую диаграмму
plt.figure(figsize=(10,6))
sns.barplot(x='month', y='id', data=df_hip5_month, palette='Blues')

for i, val in enumerate(df_hip5_month['id'].values):
    plt.text(i, val, int(val), horizontalalignment='center', verticalalignment='bottom', fontdict={'fontweight':500, 'size':12})

plt.xlabel('Месяц рождения')
plt.ylabel('Количество хоккеистов')

plt.show()

"""Можем провести статистический тест, сравнить две выборки месяцев. Первая выборка будет содержать месяца рождения успешных хоккеистов. Вторую выборку сформируем в противоположность первой, т.е. отберем равное количество хоккеистов с каждой позиции, но с низкими оценками."""

# вырорка 1 - месяцы рождения успешных хоккеистов
v_1 = list(df_hip5_1['month'])
len(v_1)

# количество успешных берем в соответствии с рассчитанным числом 20% от всех по позиции
not_success_players = (
    list(forward_points.sort_values(by='sum_points')['id'].head(df_position.loc[0, 'count_best'])) +
    list(goaltender_points.sort_values(by='sum_points')['id'].head(df_position.loc[1, 'count_best'])) +
    list(defense_points.sort_values(by='sum_points')['id'].head(df_position.loc[2, 'count_best']))
)


# оставляем в таблице только неуспешных игроков
df_hip5_3 = df_hip5.query('id in @not_success_players')


# вырорка 2 - месяцы рождения неуспешных хоккеистов
v_2 = list(df_hip5_3['month'])
len(v_2)

"""Имея две выборки с месяцами с равным количеством можем провести сравнение средних выполнив ttest.

Нулевая гипотеза -- средние двух выборок равны

Альтернативная -- средние отличаются
"""

## Нулевая гипотеза -- средние двух выборок равны
## Альтернативная -- средние отличаются

alpha = 0.05

fig, ax = plt.subplots()
ax.hist(v_1, label="S",bins=np.arange(1,12,.5),align='left', )
ax.hist(v_2, label="NS", color="green",bins=np.arange(1,12,.5),align='left')
plt.legend()

results = st.ttest_ind(
    v_1,
    v_2,
    equal_var=False)

print('p-значение:', results.pvalue)

if (results.pvalue < alpha):
    print("Отвергаем нулевую гипотезу")
else:
    print("Не получилось отвергнуть нулевую гипотезу")

"""Исходя из проведенного анализа утверждаем, что нет достаточных оснований полагать, что более успешные хоккеисты рождаются в период с марта по январь.

Дополнительно проверим гипотезу на нападающих, отберем две выборки, первая выборка - хоккеисты, родившиеся в января по март, вторая выборка - остальные месяцы. Проведем также сравнение средних, сравнение по оценкам.
"""

# к таблице нападающих добавим месяц рождения игрока

forward_points_hip = forward_points.merge(df_hip5.query('position == "forward"').reset_index()[['month', 'id']],
                                          on='id', how='left'

)

# вырорка 1 - оценки нападающих, рожденных с января по март

v_3 = list(forward_points_hip.query('month <= 3')['sum_points'])
len(v_3)

# вырорка 2 - оценки нападающих, рожденных с апреля по декабрь
# выбираем случайнные данные в размер первой выборке

v_4 = list(forward_points_hip.query('month > 3')['sum_points'])
len(v_4)

## Нулевая гипотеза -- средние двух выборок равны
## Альтернативная -- средние отличаются

alpha = 0.05

results = st.ttest_ind(
    v_3,
    v_4,
    equal_var=False)

print('p-значение:', results.pvalue)

if (results.pvalue < alpha):
    print("Отвергаем нулевую гипотезу")
else:
    print("Не получилось отвергнуть нулевую гипотезу")

"""Также подстверждена гипотеза, что нет разницы между оценками хоккеистов, рожденных с января по март, и оценками  хоккеистов, рожденных в остальные месяцы.

В данном случае следует говорить об [эффекте Матфея](https://www.mann-ivanov-ferber.ru/assets/files/bookparts/the-story-of-succes/genii_mail.pdf). Отбор игроков в хоккейные школы зачастую происходит в начале года, значит если хоккеист родится в конце года, у него меньше шансов пройти, т.к. он еще не дорос. Поэтому в общем плане, хоккеистов рожденных в первые месяцы года больше.

**Гипотеза о том, что наиболее успешные хоккеисты рождаются с января по март, не подстверждена.**

## Выводы работы

Были исследованы данные по хоккеистам, игравшим в командах лиги КХЛ.

Основная цель работы заключалась в поиске "Числа Лемтюгова", т.е. связь игроков лиги КХЛ с Николаем Лемтюговым. Для этого из данных была подготовлена таблица одноклубников, посредством которой был создан граф, через который было посчитано "Число Лемтюгова" для каждого хоккеиста. Максимальное число равно 3. Доказана связь между количеством переходов у хоккеиста и значением "Числа Лемтюгова", так чем больше хоккеист сменил команд, чем больше у него был шанс приобрести новых одноклубников и получить меньше число. Например, для игроков побывавших только в одной команде, на момент исследования, "Число Лемтюгова" максимально и равно 3, т.е. они связаны с Николаем через 3 рукопожатия.


В ходе работы также была проведена статистика по игрокам и их переходам в клубах лиги КХЛ. Так, например, по числу переходов выделились Михаил Жуков и Евгений Лапенков, они сменили по 14 команд, а Николай Лемтюгов 11 команд. Наибольшее количество одноклубников имеет Евгений Лапенков - 475. Для него был проведен расчет его числа, который в максимуме также составляет 3. У Николая Лемтюгова было 357 одноклубников. Были выявлены команды, сменившие наибольшее количество игроков: Амур, Спартак, Нефтехимик, Торпедо и Витязь, от 346 до 370 хоккеистов побывало в составе этих команд.


В дополнение к работе были рассмотрены гипотезы:
1. Николай Лемтюгов самый популярный хоккеист. -- Не подтверждена, самый популярный хоккеист Денис Казионов.

2. Игроки с низким значение "Числа Лемтюгова" в среднем играли в большем количестве команд. -- Подтверждена, игроки с меньшим количеством переходом имеют меньше одноклубников в общем числе, поэтому находятся дальше от Лемтюгова.

3. Существует связь между количеством переходов и ростом/весом игрока. -- Не подтверждена, связь не найдена.

4. Существует связь между местом рождения и успехами хоккеиста. -- Не подтверждена, место рождение хоккеистов рассредоточено по миру, в большинстве, сконцентрировано в центральной части до 59' широты.

5. Наиболее успешные хоккеисты рождаются в период с января по март. -- Не подтверждена, в целом большая часть хоккеистов рождается в первой половине года, но это связано с принципом отбора в хоккейные школы, при сравнении показателей успешности не выявлено связи с месяцем рождения.
"""